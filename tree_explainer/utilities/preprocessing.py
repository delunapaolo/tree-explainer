import numpy as np
import pandas as pd


class DataProcessor(object):
    def __init__(self):
        self.info = dict()
        self.data = None
        self.targets = None


    def prepare(self, data=None, targets=None, data_column_names=None, target_name=None):
        # Check that there is something to do
        if data is None and targets is None:
            raise ValueError('Provide data and/or targets')

        if data is not None:
            self._process_data(data, data_column_names)

        if targets is not None:
            self._process_targets(targets, target_name)

        return self


    def _process_data(self, data, data_column_names=None):
        # Initialize output variable
        info = dict()

        # Get feature names
        if isinstance(data, (pd.DataFrame, pd.Series)):
            if isinstance(data, pd.Series):
                raise NotImplementedError
            # Infer feature names
            data_column_names = list(data.columns)
            # Make local copy
            data = data.copy()
            data.reset_index(drop=True, inplace=True)
        else:
            if data_column_names is None:
                data_column_names = ['variable_%i' % (i + 1) for i in range(data.shape[1])]
            # Convert to a DataFrame
            data = pd.DataFrame(data, columns=data_column_names)
        # Store feature names
        info['original_feature_names'] = data_column_names

        # Retrieve information on categorical features
        features_data_types = dict()
        for feature in data_column_names:
            # Get description of data type
            dtype = data.dtypes[feature]
            if dtype.name == 'category':  # == pd.Categorical
                if dtype.ordered:
                    data_type = 'ordinal'
                else:
                    data_type = 'nominal'
                categories = np.array(data[feature].cat.categories)

            elif dtype.name == 'object':  # Most likely a string
                data_type = 'nominal'
                categories = np.unique(data[feature])

            else:
                data_type = 'numerical'
                categories = None

            # Store information
            features_data_types[feature] = dict(data_type=data_type)
            if categories is not None:
                features_data_types[feature]['categories'] = categories

        # Mark nominal features to be one-hot encoded, and mark ordinal variables
        # to be converted to numeric
        # columns_to_convert_to_dummies = [i for i, j in
        #                                  features_data_types.items()
        #                                  if j['data_type'] == '__']
        columns_to_convert_to_numerical = [i for i, j in
                                           features_data_types.items()
                                           if j['data_type'] in ['ordinal', 'nominal']]

        # Convert data
        # if len(columns_to_convert_to_dummies) > 0:
        #     list_of_features = list(data.columns)
        #     # Call pd.get_dummies() on individual columns
        #     for feature in columns_to_convert_to_dummies:
        #         # Check whether this feature contains NaN. If so, we'll add a
        #         # new column for that
        #         dummy_na = data[feature].isna().any()
        #         # Create new features
        #         engineered_feature = pd.get_dummies(data[feature],
        #                                             prefix=feature, prefix_sep='_',
        #                                             dummy_na=dummy_na, drop_first=True)
        #         # Store list of feature generated by the current one
        #         features_data_types[feature]['child_features'] = list(engineered_feature.columns)
        #         # Append to data
        #         data.drop(columns=feature, inplace=True)
        #         data = pd.concat((data, engineered_feature), axis=1,
        #                          sort=False, copy=False)
        #         # Replace feature in list
        #         idx = list_of_features.index(feature)
        #         list_of_features.remove(feature)
        #         list_of_features.insert(idx, list(engineered_feature.columns))
        #
        #     # Re-sort columns in data
        #     data = data[np.hstack(list_of_features)]

        if len(columns_to_convert_to_numerical) > 0:
            for feature in columns_to_convert_to_numerical:
                categories = features_data_types[feature]['categories']
                categories_lookup = dict({i: j for i, j in zip(categories, np.arange(categories.shape[0]))})
                # Convert data
                data[feature] = data[feature].replace(categories_lookup)

        # Store information
        info['features_data_types'] = features_data_types
        info['feature_names'] = list(data.columns)
        info['n_features'] = len(info['feature_names'])

        # Store all information and converted X
        self.data = data.values.astype(np.float32)
        self.info.update(info)


    def _process_targets(self, targets, target_name):
        # Initialize output variable
        info = dict()

        # Get names of targets
        n_target_levels = np.unique(targets).shape[0]
        info['n_target_levels'] = n_target_levels
        if isinstance(targets, (pd.DataFrame, pd.Series)):
            # Make local copy
            targets = targets.copy()
            # Convert Series to DataFrame
            if isinstance(targets, pd.Series):
                targets = targets.to_frame()
            targets.reset_index(drop=True, inplace=True)
            # Infer target name
            target_name = list(targets.columns)[0]

        else:
            if target_name is None:
                target_name = 'target'

        # Store name of target
        info['target_name'] = target_name

        # Process target variable
        target_data_type = dict()
        # Get description of X type
        dtype = targets.dtypes[target_name]
        if dtype.name == 'category':  # == pd.Categorical
            if dtype.ordered:
                data_type = 'ordinal'
            else:
                data_type = 'nominal'
            categories = np.array(targets[target_name].cat.categories)

        elif dtype.name == 'object':  # Most likely a string
            data_type = 'nominal'
            categories = np.unique(targets[target_name])

        else:
            data_type = 'numerical'
            categories = np.unique(targets[target_name])

        # Store information
        target_data_type[target_name] = dict(data_type=data_type, categories=categories)
        info['target_levels'] = categories

        # Mark nominal and ordinal features to be converted to numeric
        columns_to_convert_to_numerical = [i for i, j in
                                           target_data_type.items()
                                           if j['data_type'] in ['ordinal', 'nominal']]
        # Convert targets
        if len(columns_to_convert_to_numerical) > 0:
            # Retrieve categories and make look-up table to convert categories
            # to numbers
            categories = target_data_type[target_name]['categories']
            categories_lookup = dict({i: j for i, j in zip(categories, np.arange(categories.shape[0]))})
            # Convert X
            targets[target_name] = targets[target_name].replace(categories_lookup)

        # Store information on categorical variables
        info['target_data_type'] = target_data_type

        # Store all information and converted targets
        self.targets = np.array(targets.values).ravel()
        self.info.update(info)
